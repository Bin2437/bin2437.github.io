<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>getshell后的一些常用命令</title>
    <url>/2020/02/27/getshell%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>通过骚操作get到目标机的shell后，对其进一步利用…..</p>
<p>还是得收藏记录一下这些Dos命令，便于自己查找</p>
<a id="more"></a>

<p>记录常用的一些Dos命令，不对命令的语法和参数详细注解，毕竟/?都可以看见。</p>
<h5 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h5><ul>
<li><p>systeminfo</p>
<p>该命令是<a href="https://baike.baidu.com/item/Windows" target="_blank" rel="noopener">Windows</a>中用于显示关于计算机及其操作系统的详细配置信息，包括操作系统配置、<a href="https://baike.baidu.com/item/安全信息/12744917" target="_blank" rel="noopener">安全信息</a>、产品 ID 和硬件属性，如 <a href="https://baike.baidu.com/item/RAM" target="_blank" rel="noopener">RAM</a>、磁盘空间和网卡和补丁信息等。</p>
</li>
<li><p>ipconfig</p>
<p>显示当前电脑的TCP/IP网络配置值，排除本机网络故障的必备命令</p>
<ul>
<li><p><strong>ipconfig /all</strong></p>
<p>ipconfig命令只是显示活跃的网卡，简要的网卡信息内容</p>
<p>ipconfig /all 可以显示网卡的详细信息，包含未激活的网卡链接信息</p>
</li>
<li><p><strong>ipconfig /flushdns</strong></p>
<p>用来刷新本机dns缓存</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>whoami</p>
<p><strong>Who am i</strong>(我是谁？)</p>
<p>显示登录名，这一命令被大部分Unix类操作系统以及Windows系统包含</p>
<p>是<a href="https://baike.baidu.com/item/操作系统/192" target="_blank" rel="noopener">操作系统</a>中用于查看当前有效<a href="https://baike.baidu.com/item/用户名/7241132" target="_blank" rel="noopener">用户名</a>的命令，调用该命令时系统会输出当前用户的有效用户名,这一输出效果与<a href="https://baike.baidu.com/item/Unix/219943" target="_blank" rel="noopener">Unix</a>命令<strong>id-un</strong>是相同的。</p>
</li>
<li><p>netstat</p>
<p>查看本机开放的端口和连接信息</p>
<ul>
<li><p>netstat -an</p>
<p>-a选项显示所有连接，当不加-n选项时，它显示的是本地计算机的netbios名字和端口号</p>
<p>-n选项加上显示的是本地的IP地址和端口号</p>
</li>
</ul>
</li>
<li><p>ver</p>
<p>VERSION单词的缩写，查看当前操作系统的版本号。</p>
<p>在win7下，操作系统的版本号还是以6开头的。</p>
</li>
<li><p>hostname</p>
<p>host name嘛</p>
<p>打印当前的主机名称</p>
</li>
<li><p>net</p>
<ul>
<li><p>net user</p>
<p>官方<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc771865(v=ws.11)" target="_blank" rel="noopener">Doc</a>，里边有写语法和参数，非常详尽，直接运行可以输出当前操作系统的所有普通用户</p>
<p>主要用于操作用户，添加、更改、删除等</p>
<p>/add 添加</p>
<p>/active:yes 激活用户</p>
</li>
<li><p>net user guest</p>
<p>查看guest来宾账户的详细信息</p>
</li>
<li><p>net user administrator</p>
<p>查看administrator账户的详细信息</p>
</li>
<li><p>net localgroup</p>
<p>可以查看、添加、修改或者删除本地用户组。直接输入可以查看本地用户组信息。</p>
</li>
<li><p>net localgroup administrators</p>
<p>net localfroup Administrator可以查看某个用户组的详细信息</p>
<p><a href="https://jingyan.baidu.com/article/ce436649dfe5723773afd3aa.html" target="_blank" rel="noopener">百度经验</a></p>
</li>
</ul>
</li>
<li><p>schtasks</p>
<p>允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任务。</p>
<p>/query 显示所有计划任务</p>
<p>/create 创建新的计划任务</p>
<p>/delete 删除计划任务</p>
<p>/run 按需运行计划任务</p>
<p>/end 中止当前正在运行的计划任务</p>
</li>
<li><p>tasklist</p>
<p>用来显示运行在本地或远程计算机上的所有进程的命令行工具，带有多个执行参数。显示结果由这五部分组成图像名（进程名）、PID、会话名、会话＃、内存使用。</p>
</li>
<li><p>route</p>
<p>显示路由，修改网络的命令。</p>
<p>该命令用于在本地IP路由表中显示和修改条目。</p>
<p><strong>route print</strong>命令可以查看路由表。</p>
</li>
<li><p>arp</p>
<p><strong>arp -a</strong> 查看所有ARP缓存表中的所有信息</p>
</li>
<li><p>sc</p>
<p>SC命令不能单独使用,必须和其它的命令结合起来一起使用。</p>
<p>sc query type=service  state =all 只列举出系统服务，不论什么状态</p>
</li>
<li><p>tree</p>
<p>以图形方式显示在驱动器中的目录结构或磁盘的路径。</p>
<p>tree 显示当前文件夹下所有文件夹【不显示文件】</p>
<p>tree -f 递归显示所有文件和文件夹</p>
<p>tree -a 和tree显示类似，只是不用图形进行显示</p>
</li>
</ul>
]]></content>
      <categories>
        <category>-[getshell,cmd,命令]</category>
      </categories>
      <tags>
        <tag>getshell</tag>
        <tag>cmd</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入之-联合注入</title>
    <url>/2020/02/15/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<p>SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p>
</blockquote>
<a id="more"></a>

<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><p><strong>能够产生SQL注入的地方，一定都是和数据库有交互的</strong></p>
<h4 id="手工注入步骤"><a href="#手工注入步骤" class="headerlink" title="手工注入步骤"></a>手工注入步骤</h4><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><ul>
<li>寻找可疑注入点，并测试</li>
<li>判断注入点闭合类型</li>
<li>确定查询字段数量</li>
<li>查看数据显示位置</li>
<li>在对应显示位获取当前数据库版本，数据库名，当前连接用户名信息</li>
<li>获取全部数据库名</li>
<li>获取当前数据库下全部表名</li>
<li>寻找关键（表名有特殊含义的，如manage/admin/user等）表，获取列名</li>
<li>获取数据</li>
</ul>
<p>拿sqli-labs这个靶场来测试，Less-1</p>
<p>靶场航班<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener"靶场链接"">sqli-labs</a></p>
<p><strong>当然，这里的步骤仅仅是以MySQL作为对象进行测试，并且版本不低于5.0</strong></p>
<h5 id="寻找可疑注入点，并测试"><a href="#寻找可疑注入点，并测试" class="headerlink" title="寻找可疑注入点，并测试"></a>寻找可疑注入点，并测试</h5><p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/1.png-cpolo.cn" alt="寻找可疑注入点并测试"></p>
<p>因为是靶场可以看见是有相应的提示的，如图框起来的就是提示。让我们输入一个ID作为参数，这个就不多说了。注入点就是这个ID，但是我们可以看见页面也没什么可以输入的地方，经过测试就是在URL自己构造添加一个ID的参数，并给它赋值就可以get到我们数据库的信息</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/2.png-cpolo.cn" alt="寻找可疑注入点并测试"></p>
<p>看见有数据从页面上显示了，我们再对id这个参数的值进行一番构造。进行测试，看其是否有可能存在注入，在参数id的值后边加上常用的闭合</p>
<p>id=1’</p>
<p>id=1”</p>
<p>发现如果闭合为单引号他就会报错，如果是双引号则会正常显示，那么这基本就确认这个url是存在sql注入漏洞的</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/3.png-cpolo.cn" alt="寻找可疑注入点并测试"></p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/4.png-cpolo.cn" alt="寻找可疑注入点并测试"></p>
<h5 id="判断注入点闭合类型"><a href="#判断注入点闭合类型" class="headerlink" title="判断注入点闭合类型"></a>判断注入点闭合类型</h5><p>这个靶场基本囊括了我们常用的引号闭合</p>
<ul>
<li>单引号</li>
<li>双引号</li>
<li>无引号</li>
<li>圆括号</li>
</ul>
<p>查询语句分别为有以下这6种情况，靶场中的实际语句</p>
<ol>
<li>SELECT * FROM users WHERE id=’$id’ LIMIT 0,1</li>
<li>SELECT * FROM users WHERE id=”$id” LIMIT 0,1</li>
<li>SELECT * FROM users WHERE id=$id LIMIT 0,1</li>
<li>SELECT * FROM users WHERE id=(‘$id’) LIMIT 0,1</li>
<li>SELECT * FROM users WHERE id=(“$id”) LIMIT 0,1</li>
<li>SELECT * FROM users WHERE id=($id) LIMIT 0,1</li>
</ol>
<p>这6种情况就分别对应了不同的闭合情况</p>
<p>有幸我们是站在前人的肩膀上继续探索，我刚开始学习的时候我的老师就给了我他实战多年对引号闭合的总结：</p>
<blockquote>
<p>单引号中插入双引号不会报错，不影响执行，但是数字型和双引号中插入双引号会报错</p>
<p>双引号中插入单引号不会报错，不影响执行，但是数字型和单引号中插入单引号会报错</p>
</blockquote>
<p>这两句话适用在没有括号参与闭合的情况下，虽然有点拗口，但是对判断常规闭合有着非常大的帮助。</p>
<p>由上边的结论也可以判定出，Less-1的id的闭合为单引号，因为使用了单引号闭合之后，页面中就show出了错误信息</p>
<h5 id="确定查询字段数量"><a href="#确定查询字段数量" class="headerlink" title="确定查询字段数量"></a>确定查询字段数量</h5><p>从这一部开始往下就用到了一些常用的SQL语句，我们来确定查询字段数量就用到了<strong>ORDER BY</strong>子句</p>
<blockquote>
<h6 id="ORDER-BY-语句"><a href="#ORDER-BY-语句" class="headerlink" title="ORDER BY 语句"></a>ORDER BY 语句</h6><p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p>
<p>ORDER BY 语句默认按照升序对记录进行排序。</p>
<p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p>
</blockquote>
<p>可以看到ORDER BY子句的主要作用是排序，但是也可帮助我们确定程序开发者写的SQL语句从数据库中查询的字段数量</p>
<p>使用 <strong>ORDER BY num</strong>，num是一个数值，用来指定我们从查询字段的第几列进行排序。可以是1也可以是100，通常我们使用1是肯定不会报错的</p>
<p>聪明的人可能已经明白了，我们是使用报错来帮助我们确定我们是否是判断对了查询的字段数，我们一般使用<strong>二分法</strong>，一步步确定查询字段数</p>
<p>试试100！ORDER BY 100</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/5.png-cpolo.cn" alt="判断查询字段数量"></p>
<p>看上图可以发现，诶，果然有报错！Unknown column ‘100’ in ‘order clause’ ！未知的列，有细心的同学又发现了，<strong>–+</strong>怎么语句后边跟了这三个符号，这也涉及到SQL语言的注释，毕竟sql也是一门语言，<strong>通用的结构化查询语言</strong></p>
<h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><p>SQL语法中，注释分单行注释和多行注释。我们用到的当然就是单行注释了</p>
<ul>
<li><p>单行注释</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1. <span class="comment">-- </span></span><br><span class="line">  "<span class="comment">-- "这里是两条横杠加一个空格</span></span><br><span class="line">2. <span class="comment">#</span></span><br><span class="line">  这就是一口井</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>多行注释</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>但是为什么我们这里使用了–+呢，这又涉及到浏览器url编码的问题，总之一句话，浏览器默认对url进行编码时候会吧加号“+”变成空格“ ”，所以我们使用“–+”就相当于“– ”</p>
<p>注释完了就是接着判断查询字段数量，采用二分法，我们这次试试50，结果依然是会报错，接着就是25-&gt;12-&gt;6发现依然会报错，没事继续！</p>
<p>ORDER BY 3 诶，好了就，发现就是正常显示了，那么这就表示目前查询字段数是至少存在3列的情况，但是我们依然不能完全确定就是3列，我们还需要往前推，ORDER BY 4试试，发现报错。由此可确定查询字段数为3！</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/6.png-cpolo.cn" alt="判断查询字段数"></p>
<h5 id="查看数据显示位置"><a href="#查看数据显示位置" class="headerlink" title="查看数据显示位置"></a>查看数据显示位置</h5><p>进入正题了，从这步开始就可以获取数据库各种信息了！23333</p>
<p>这次使用的就是UNION操作符</p>
<blockquote>
<h6 id="SQL-UNION-操作符"><a href="#SQL-UNION-操作符" class="headerlink" title="SQL UNION 操作符"></a>SQL UNION 操作符</h6><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</p>
</blockquote>
<p>也就是说通过UNION操作符可以拼接一条我们恶意构造的查询语句到原本查询语句的后面提交给程序执行，最后就可以返回我们想要的结果</p>
<p>因为确定了查询字段数为3，所以现在构造的语句就是这样的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment">--+' LIMIT 0,1</span></span><br></pre></td></tr></table></figure>

<p>这里的 <strong>SELECT 1,2,3</strong>，为什么我们要使用1,2,3呢，这只是一个例子，UNION操作符的语法有写，UNION内部的SELECT语句必须拥有相同数量的列，所以我们在后边使用的1,2,3就相当于占位符，并且也不限制从小到大写，这只是为了方便我们辨认显示位。只要能记住也可以写成 SELECT 1000,10,100</p>
<p>当然还有为什么现在ID=-1了呢？这里让它等于-1主要是为了让程序自带的SELECT从数据库查询不到结果，然后我们自己构造的恶意语句的执行结果才能显示在页面上。这里=-1仅仅其实不怎么推荐使用=-1，因为可能真是环境中装有WAF而对这个“-”号做了相应的防御，建议使用一个超大的数值来代替，目的就是为了让程序自带的SELECT从数据库中获取不到结果就对了，可以使用999999，100000都行，效果一样的</p>
<p>所以在url传递进去的参数就是这样的</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/7.png-cpolo.cn" alt="查看数据显示位置"></p>
<p>可以看见页面上原本的DUMB和DUMB现在成了2,3，所以通过这个回显就可以知道，页面上的显示位是使用的查询出来的第2列和第三列的数据</p>
<h5 id="在对应显示位获取当前数据库版本，数据库名，当前连接用户名信息"><a href="#在对应显示位获取当前数据库版本，数据库名，当前连接用户名信息" class="headerlink" title="在对应显示位获取当前数据库版本，数据库名，当前连接用户名信息"></a>在对应显示位获取当前数据库版本，数据库名，当前连接用户名信息</h5><p>上一步知道了页面中有两个显示位置，姑且称之为2号位和3号位</p>
<p>我们获取数据就需要在这个2号位或者三号位动手脚，也可以一起爆！</p>
<h6 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h6><ul>
<li><p>version()</p>
</li>
<li><p>database()</p>
</li>
<li><p>user()</p>
</li>
<li><p>@@datadir</p>
<p>看这些函数名称就知道他们能获取到的信息，不再过多介绍，这里也仅仅列出常用的这几个</p>
</li>
</ul>
<p>那我们就把2号位和3号位替换成database()和version()试试！我靠，出来了</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/8.png-cpolo.cn" alt="查看数据显示位置"></p>
<p>可以看见在相应的显示位打印出来了当前站点使用的数据库名，还有数据库服务器版本。</p>
<h5 id="获取全部数据库名"><a href="#获取全部数据库名" class="headerlink" title="获取全部数据库名"></a>获取全部数据库名</h5><h6 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h6><p>其实这一步也可以省略，但是并不建议这样做。因为可能在那个数据库中存在的数据库并不仅仅只有当前网站的数据库，可能这个站还存在旁站等等，如果可以的话，这样收集到的信息会更全面</p>
<h6 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h6><p>因为我们的显示位置一次只能显示一条数据，但是我们又想一次性的获取到更多数据就需要这些<strong>聚合函数</strong>来帮我们实现了</p>
<ul>
<li><p>concat()</p>
<ul>
<li>将多个字符串连接成一个字符串</li>
<li>语法：concat(str1,str2)</li>
<li>返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null</li>
</ul>
</li>
<li><p>group_concat()</p>
<ul>
<li>group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’])</li>
</ul>
<p>我常用的基本也就这两个，也可以组合到一起</p>
</li>
</ul>
<p>我们现在的语句就是这样的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="keyword">GROUP_CONCAT</span>(schema_name),<span class="number">3</span> <span class="keyword">FROM</span> information_schema.schemata <span class="comment">--+' LIMIT 0,1</span></span><br></pre></td></tr></table></figure>

<p>可以看见，我们使用聚合函数把schema_name这列的数据给拼接了起来，并且是通过information_schema这个数据库表查出来的</p>
<h6 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h6><p>到了这儿有不得不说这个information_schema，这是在大于5.0版本的mysql服务器中才有的一张数据库表。其实说它是一张表并不准确，准确的来说它实际上是一个视图，而不是一个基本表！它存储了关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</p>
<p>我们需要重视的主要就是其中的这些表，以及表中这些相应的字段</p>
<ul>
<li>schemata<ul>
<li>schema_name<ul>
<li>存储所有数据库的字段名</li>
</ul>
</li>
</ul>
</li>
<li>tables<ul>
<li>table_name<ul>
<li>存储所有数据表的字段名</li>
</ul>
</li>
<li>table_schema<ul>
<li>存储表归属与哪个数据库的字段名</li>
</ul>
</li>
</ul>
</li>
<li>columns<ul>
<li>column_name<ul>
<li>存储表中所有列的字段名</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有了这些信息，我们就可以更进一步的来准确获取到我们想要的东西！</p>
<p>所以来看看这么执行会有什么结果</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/9.png-cpolo.cn" alt="获取全部数据库名"></p>
<p>是的，这样就把数据库中存在的所有数据库给一一展示了出来！得劲吧。如果没有GROUP_CONCAT()聚合函数，取得的结果就只能是查询出来的第一个结果，就会相当于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span>,schema_name,<span class="number">3</span> <span class="keyword">FROM</span> information_schema.schemata <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">1</span> <span class="comment">--+' LIMIT 0,1</span></span><br></pre></td></tr></table></figure>

<p>这样虽然也可以通过LIMIT的值来一下一下取，但是我相信各位童鞋应该都熬不住这样的诱惑，应该想一下子把它扒光吧，这样是不是很刺激。[手动鼻血]</p>
<h6 id="获得目标站点所使用的数据库"><a href="#获得目标站点所使用的数据库" class="headerlink" title="获得目标站点所使用的数据库"></a>获得目标站点所使用的数据库</h6><p><strong>可以跳过的</strong>其实这是一堆自言自语，因为这文章是昨晚上写的，我都忘了有没有介绍这个，敲完了才记起来上一步就已经介绍了，凑个字数，莫见怪。</p>
<p>这里再说一句，我们是看见了全部的数据库名，但是如果真的在目标服务器上有非常多的数据库我们怎么才能快速的找到并定位当前站点所使用的是哪个库呢，当然，一般数据库的名字起得应该都是有含义的，大部分可以通过字面意思就能大概确定这个库就是干嘛的，属于哪个站的。但是毕竟也有万一，万一库太多了（我就遇到过多次，存了有五六百个库。。）那岂不是找死，所以才有了上一步中直接使用database()方法来直接获取当前站点使用的数据库，方便吧！</p>
<h5 id="获取当前数据库下全部表名"><a href="#获取当前数据库下全部表名" class="headerlink" title="获取当前数据库下全部表名"></a>获取当前数据库下全部表名</h5><p>有了前几步的铺垫，接下来的步骤简直就相当于囊中取物-轻轻松松</p>
<p>因为我们光获取到了全部的数据库名也不够啊，如果不知道数据库中的表名，还有字段名也根本没法查数据啊，所以还得继续利用information_schema存的信息，所以这一步构造的语句就是这样的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="keyword">GROUP_CONCAT</span>(table_name),<span class="number">3</span> <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema=<span class="keyword">database</span>() <span class="comment">--+' LIMIT 0,1</span></span><br></pre></td></tr></table></figure>

<p>注意，这里使用的就是tables这张表了，并且指定table_schema等于当前数据库，table_schema这个字段存储的就是该表示属于哪个数据库的，所以这里指定为当前数据库，当然也可以手动指定，但建议还是直接使用database()好点，orz</p>
<p>所以，执行结果就是这样的</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/10.png-cpolo.cn" alt="获取当前数据线下的全部表名"></p>
<p>已经get到了security库里边所有的数据表名字，emails、referers、uagents、users</p>
<h5 id="寻找关键表，获取表中字段名"><a href="#寻找关键表，获取表中字段名" class="headerlink" title="寻找关键表，获取表中字段名"></a>寻找关键表，获取表中字段名</h5><p>上一步已经获得了当前数据库中的所有表，所以离爆关键数据又进了一步，这个关键表也不多说了吧，都能明白。哪种数据的价值对我们来说最大，当然是管理员信息，用户信息咯。看表名一般带有manage、uesr、users、admin等等的表就优先开始进行这一步：取得表中字段名</p>
<p>所以接下来的语句就是酱紫</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="keyword">GROUP_CONCAT</span>(column_name),<span class="number">3</span> <span class="keyword">FROM</span> information_schema.columns <span class="keyword">WHERE</span> table_schema=<span class="keyword">database</span>() <span class="keyword">AND</span> table_name=<span class="string">'users'</span> <span class="comment">--+' LIMIT 0,1</span></span><br></pre></td></tr></table></figure>

<p>这里也不再多解释原理，跟上一步上不多的意思，只不过是查询的表换了一张，WHERE子句的条件也跟着变更了，执行结果如下</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/11.png-cpolo.cn" alt="获取表中所有字段名"></p>
<p>我们成功的取得了users表中的所有字段名，好了，接下来就是最后一步了，激动人心的时刻就到了</p>
<h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>因为我们已经get到了我们需要得到最后数据的所有数据，有点拗口哦，理理。</p>
<p>我们确定了当前数据库，取得了关键表名字，并且获得了表中的字段名，所以最后一步就是带上这些条件，抛开information_schema，愉快的爆数据吧！语句如下，我好累。。。现在头好胀</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="keyword">GROUP_CONCAT</span>(<span class="keyword">CONCAT</span>(<span class="keyword">id</span>,<span class="string">"用户名"</span>,username,<span class="string">"密码"</span>,<span class="keyword">password</span>,<span class="string">"&lt;br /&gt;"</span>),<span class="number">3</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="comment">--+' LIMIT 0,1</span></span><br></pre></td></tr></table></figure>

<p>这里就把CONCAT()和GROUP_CONCAT()两个聚合函数结合了使用，并且在查询的字段间使用了分隔符，当然，这里仅仅是演示这么做，不一定非得这样，只是为了让数据看的更清晰一点。可以自行替换或者删除这些分隔符</p>
<p>那么执行结果就是如下</p>
<p><img src="https://image.cpolo.cn/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/12.png-cpolo.cn" alt="获取表中所有数据"></p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>写了这么多字一方面是帮助自己回忆，另一方面也是做个笔记，防止哪天自己给忘了。。</p>
<p><strong>我们最后一步是直接把数据库的所有数据给爆了出来，因为这是靶场，在真实环境中，我们一定不能这么做，具体原因请百度我国的网络安全法，我们白帽子一定要学会保护自己，一定别忘了加上 LIMIT 0,3</strong></p>
<p>写不下去了，谢谢你拥有如此意志力可以把这篇又双叒叕长又杂的笔记读完。</p>
<p>如果觉得本文对你有帮助，也欢迎你点击下边赞赏请博主喝一杯茶或者一杯咖啡啦！</p>
]]></content>
      <tags>
        <tag>WEB安全</tag>
        <tag>SQL注入</tag>
        <tag>联合注入</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计</title>
    <url>/2020/02/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><blockquote>
<p>顾名思义就是检查<a href="https://baike.baidu.com/item/源代码/3969" target="_blank" rel="noopener">源代码</a>中的安全缺陷，检查程序源代码是否存在安全隐患，或者有编码不规范的地方，通过自动化工具或者人工审查的方式，对程序源代码逐条进行检查和分析，发现这些源代码缺陷引发的安全漏洞，并提供代码修订措施和建议。</p>
</blockquote>
<a id="more"></a>

<h3 id="通用审计思路"><a href="#通用审计思路" class="headerlink" title="通用审计思路"></a>通用审计思路</h3><ul>
<li><p>根据敏感函数回溯参数传递过程</p>
<ul>
<li><p>优点</p>
<p>只需要搜索相应敏感关键字，即可快速地挖掘想要的漏洞，具有可定向挖掘和高效、高质量的优点</p>
</li>
<li><p>缺点</p>
<p>由于没有通读代码，对程序的整体框架了解不够深入，在挖掘漏洞时定位利用点会话费一点时间，另外对逻辑漏洞会覆盖不到</p>
</li>
</ul>
</li>
<li><p>查找可控变量，正向追踪变量传递过程</p>
</li>
<li><p>寻找敏感功能点，通读功能点代码</p>
<ul>
<li>几种经常出现漏洞的功能点<ul>
<li>文件上传功能</li>
<li>文件管理功能</li>
<li>登录认证 功能</li>
<li>找回密码功能</li>
</ul>
</li>
</ul>
</li>
<li><p>直接通读全文代码</p>
<ul>
<li>流程<ul>
<li>查看网站逻辑结构</li>
<li>审计关键文件代码</li>
<li>审计配置文件</li>
<li>审计如index.php入口文件</li>
<li>审计其它功能入口文件</li>
</ul>
</li>
<li>优点<ul>
<li>更好的了解程序的架构以及业务逻辑，能够挖掘到更多，更高质量的逻辑漏洞</li>
</ul>
</li>
<li>缺点<ul>
<li>话费的时间比较多，新手用这种方式比较吃力</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常见的危险函数和特殊函数"><a href="#常见的危险函数和特殊函数" class="headerlink" title="常见的危险函数和特殊函数"></a>常见的危险函数和特殊函数</h3><ul>
<li><p>PHP代码执行函数</p>
<ul>
<li>eval ( string <code>$code</code> ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><ul>
<li>把字符串作为PHP代码来执行</li>
<li>很多常见的webshell都是利用eval()来执行具体操作的</li>
</ul>
</li>
<li>assert()<ul>
<li>版本<ul>
<li>PHP 5<ul>
<li>assert ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$assertion</code> [, string <code>$description</code> ] ) : bool</li>
</ul>
</li>
<li>PHP 7<ul>
<li>assert ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$assertion</code> [, Throwable <code>$exception</code> ] ) : bool</li>
</ul>
</li>
</ul>
</li>
<li>检查指定的 <code>assertion</code> 并在结果为 <strong><code>FALSE</code></strong> 时采取适当的行动。<ul>
<li>如果 <code>assertion</code> 是字符串，它将会被 <strong>assert()</strong> 当做 PHP 代码来执行。 <code>assertion</code> 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 <code>assertion</code> 表达式。 这意味着如果你传入了 boolean 的条件作为 <code>assertion</code>，这个条件将不会显示为断言函数的参数；在调用你定义的 <a href="https://www.php.net/manual/zh/function.assert-options.php" target="_blank" rel="noopener">assert_options()</a> 处理函数时，条件会转换为字符串，而布尔值 <strong><code>FALSE</code></strong> 会被转换成空字符串。</li>
</ul>
</li>
<li>因为大多数安全软件把eval()列入黑名单了，所以利用assert()代替eval()来执行具体操作</li>
</ul>
</li>
<li>preg_replace ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$pattern</code> , <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$replacement</code> , <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$subject</code> [, int <code>$limit</code> = -1 [, int <code>&amp;$count</code> ]] ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><ul>
<li>搜索<code>subject</code>中匹配<code>pattern</code>的部分， 以<code>replacement</code>进行替换。</li>
</ul>
</li>
<li>create_function ( string <code>$args</code> , string <code>$code</code> ) : string<ul>
<li>根据传递的参数来创建一个匿名函数，并返回一个唯一的名称，一般赋给一个变量。</li>
</ul>
</li>
<li>call_user_func ( <a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">callable</a> <code>$callback</code> [, <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$parameter</code> [, <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$...</code> ]] ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><ul>
<li>第一个参数 <code>callback</code> 是被调用的回调函数，其余参数是回调函数的参数。</li>
</ul>
</li>
<li>call_user_func_array ( <a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">callable</a> <code>$callback</code> , array <code>$param_arr</code> ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><ul>
<li>把第一个参数作为回调函数（<code>callback</code>）调用，把参数数组作（<code>param_arr</code>）为回调函数的的参数传入。</li>
</ul>
</li>
</ul>
</li>
<li><p>文件包含函数</p>
<pre class="mermaid">  graph LR
A[文件包含] --> B("include()")
A --> C("require()")
A --> D("include_once()")
A --> E("require_once()")</pre>



</li>
</ul>
<p>​                   </p>
]]></content>
      <categories>
        <category>WEB安全</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo升级</title>
    <url>/2020/02/08/hexo%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了-手动狗头"><a href="#Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了-手动狗头" class="headerlink" title="Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了[手动狗头]"></a>Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了[手动狗头]</h3><h4 id="更新还是有必要的"><a href="#更新还是有必要的" class="headerlink" title="更新还是有必要的"></a>更新还是有必要的</h4><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br><span class="line">cd hexo</span><br><span class="line"># 到你博客目录下边</span><br><span class="line">ncu</span><br><span class="line"># 检查更新</span><br><span class="line">ncu -u</span><br><span class="line"># 确认升级</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p><img src="https://image.cpolo.cn/hexo%E5%8D%87%E7%BA%A7/success.png-cpolo.cn" alt="Success"></p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>npm</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu搭建VSFTPD</title>
    <url>/2020/01/27/%E6%90%AD%E5%BB%BAVSFTPD/</url>
    <content><![CDATA[<h1 id="Ubuntu-安装VSFTPD"><a href="#Ubuntu-安装VSFTPD" class="headerlink" title="Ubuntu 安装VSFTPD"></a>Ubuntu 安装VSFTPD</h1><a id="more"></a>

<h5 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y vsftpd</span><br></pre></td></tr></table></figure>

<h5 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br><span class="line"></span><br><span class="line">listen=YES</span><br><span class="line">listen_ipv6=NO</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line"><span class="meta">#</span><span class="bash">check_shell=NO</span></span><br></pre></td></tr></table></figure>

<h5 id="新建一个ftp用户"><a href="#新建一个ftp用户" class="headerlink" title="新建一个ftp用户"></a>新建一个ftp用户</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -g ftp -M -d /var/www/html/ -s /usr/bin/nologin username</span><br><span class="line">passwd username</span><br></pre></td></tr></table></figure>

<h5 id="取消vsftpd对shell的检测"><a href="#取消vsftpd对shell的检测" class="headerlink" title="取消vsftpd对shell的检测"></a>取消vsftpd对shell的检测</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/shells</span><br><span class="line"><span class="meta">#</span><span class="bash">把 /sbin/nologin /usr/bin/nologin 或者是 /bin/<span class="literal">false</span> 加到 /etc/shells 中去！</span></span><br></pre></td></tr></table></figure>

<p>其实vsftpd对本地用户鉴权的过程中是可以检查用户shell的合法性的，而且默认就启用了。虽然你可以在配置文件中通过添加 check_shell=NO来取消vsftpd对shell的检测，但是这个配置项要生效却有个前提：编译的时候不能包含PAM特性（一种*nix系统中的插件式身份鉴别模块），而ubuntu等发行版的二进制包并不能满足这点，所以除非你是自己编译的vsftpd，这个配置项是没有多少用的。</p>
<p>要解决这个问题，还得继续问：vsftpd是怎么检查一个shell是否合法呢？其实这个答案很简单，vsftpd读取 /etc/shells 这个文件，如果用户的shell在这个文件里存在，就认为合法，否则即使你输入了正确的密码，仍然会给你一个530，哈哈。<br>    所以，解决办法就是：把 /sbin/nologin /usr/bin/nologin 或者是 /bin/false 加到 /etc/shells 中去！</p>
<h5 id="配置ftp用户家目录权限"><a href="#配置ftp用户家目录权限" class="headerlink" title="配置ftp用户家目录权限"></a>配置ftp用户家目录权限</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 555 /var/www/html/</span><br></pre></td></tr></table></figure>

<p>从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报该错误。</p>
<p> 要修复这个错误，可以用命令chmod a-w /home/user去除用户主目录的写权限，注意把目录替换成你自己的。或者你可以在vsftpd的配置文件中增加下列两项中的一项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/vsftpd.conf</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac开启原生NTFS读写功能</title>
    <url>/2019/05/23/Mac%E5%BC%80%E5%90%AF%E5%8E%9F%E7%94%9FNTFS%E8%AF%BB%E5%86%99%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h4 id="Mac早在10-5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal-app来开启这个功能！"><a href="#Mac早在10-5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal-app来开启这个功能！" class="headerlink" title="Mac早在10.5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal.app来开启这个功能！"></a>Mac早在10.5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal.app来开启这个功能！</h4><a id="more"></a>

<p>打开Terminal终端工具，这是Mac自带的终端工具，非常方便好使。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">diskutil list</span><br><span class="line">//查看你电脑所有磁盘</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">diskutil info /Volumes/磁盘名 | grep UUID</span><br><span class="line">//因为UUID是磁盘真正的且是唯一的标识符，而我们的磁盘名并非总是不变的，所以使用UUID来开启NTFS读写是更佳的！</span><br></pre></td></tr></table></figure>
<p>Return (Enter) 后会出现“Volume UUID”和“Disk / Partition UUID”两行内容。<br>我们只需要使用Volume UUID即可</p>
<p>接下来复制这组UUID，再使用VIM将UUID写入/etc/fstab中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br><span class="line">//进入VIM后按i键进入编辑模式</span><br><span class="line">//将之前复制的UUID按照这个格式填入</span><br><span class="line">UUID=磁盘标识符 none ntfs rw,auto,nobrowse</span><br><span class="line">//填入完后按ESC键退出编辑模式，切换到英文半角状态":wq"，输入一个冒号wq后退出</span><br></pre></td></tr></table></figure>

<p>在磁盘工具中重新装载该磁盘后就可以对该磁盘进行写入操作了</p>
<h5 id="将存储器显示在Finder的方法其实也非常简单"><a href="#将存储器显示在Finder的方法其实也非常简单" class="headerlink" title="将存储器显示在Finder的方法其实也非常简单"></a>将存储器显示在Finder的方法其实也非常简单</h5><p>只需要将”磁盘工具”-&gt;”显示简介”-&gt;存储器Finder标题栏的图标长按并拖入Finder的个人收藏栏中就ok了</p>
]]></content>
      <tags>
        <tag>MacOS</tag>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian Linux 修改时区</title>
    <url>/2019/04/23/Ubuntu%20%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/</url>
    <content><![CDATA[<h4 id="UTC时区切换到CST时区"><a href="#UTC时区切换到CST时区" class="headerlink" title="UTC时区切换到CST时区"></a>UTC时区切换到CST时区</h4><a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "export TZ='Asia/Shanghai'" &gt;&gt; /etc/profile</span><br><span class="line"></span><br><span class="line">cat /etc/profile | grep TZ</span><br></pre></td></tr></table></figure>

<p>//查看是否写入成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/profile | grep TZ</span><br></pre></td></tr></table></figure>

<p>//编译使其生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>//查看当前时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Debian</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Debian</tag>
        <tag>时区</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx+Ngrok共用80端口</title>
    <url>/2019/04/21/Nginx-Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>大多数情况下，我们的服务器不会只有一个ngrok服务，并且80端口通常都是给Nginx等服务准备的！在一系列的需求下，Ngrok和Nginx就有共用80端口的必要</p>
<a id="more"></a>

<h3 id="解决姿势"><a href="#解决姿势" class="headerlink" title="解决姿势"></a>解决姿势</h3><p>我们的服务器一般都有着公网和内网之分，所以网卡也有两个，所以我们让Nginx监听公网80端口，Ngrok监听内网80端口就完美的解决了这个问题</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>带有公网ip的服务器一台</li>
<li>Nginx服务</li>
<li>Ngork服务</li>
</ul>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul>
<li>查看自己服务器网卡数量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>

<p><img src="https://image.cpolo.cn/Nginx+Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/ifconfig%20-a.png-cpolo.cn" alt="ifconfig -a"></p>
<p>如上图所示，我有一个内网网卡，ip是172.16.0.14，虽然我只有一个内网网卡也是可以实现的</p>
<ul>
<li>配置一个新的网卡：192.168.24.37（如果你有两块网卡请忽略这一步）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.24.37/24 up</span><br></pre></td></tr></table></figure>

<ul>
<li>再通过ifconfig -a 命令查看网卡</li>
</ul>
<p><img src="https://image.cpolo.cn/Nginx+Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/new%20eth0-0.png-cpolo.cn" alt="ifconfig -a"></p>
<p>如图，我现在有了172.16.0.14（内网网卡，但实际上我的公网ip是别的服务器转发给我这个ip的，所以这个ip对我的服务器来说，我所有的外网请求都来自这个ip）和192.168.24.37（自己添加的）</p>
<ul>
<li>修改Nginx配置文件</li>
</ul>
<p>因为我的nginx主配置文件里配置了自动加载配置文件目录下vhost子目录的所有单独的虚拟主机配置文件，所以我只需要在vhost目录下新建一个ngrok.conf文件就好了</p>
<p>配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream ngrok &#123;</span><br><span class="line">        server 192.168.24.37:80;</span><br><span class="line">        server 192.168.24.37:443;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 172.16.0.14:80;</span><br><span class="line">        server_name example.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_set_header Host $http_host;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                proxy_set_header X-Scheme $scheme;</span><br><span class="line">                proxy_pass_header Server;</span><br><span class="line">                proxy_pass http://ngrok;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用nginx来反代，不会的照着配置文件改改就好</p>
<ul>
<li>启动Ngrok监听内网(192.168.24.37)的80端口</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ngrok -domain='example.com' -httpAddr='192.168.24.37:80' -httpsAddr='192.168.24.37:443'</span><br></pre></td></tr></table></figure>

<ul>
<li>重载Nginx</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>启动ngrok客户端试试</li>
</ul>
<p><img src="https://image.cpolo.cn/Nginx+Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/startngrok.png-cpolo.cn" alt="start ngrok"></p>
<p>Beautiful</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Nginx</category>
        <category>反向代理</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Ngrok</tag>
        <tag>内网穿透</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>重建Windows引导的一次操作</title>
    <url>/2019/04/04/%E9%87%8D%E5%BB%BAWindows%E5%BC%95%E5%AF%BC%E7%9A%84%E4%B8%80%E6%AC%A1%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>由于电脑Windows和Linux系统都不在一个硬盘上，所以每个硬盘都有一个EFI分区。本着有一个引导分区就够了的原则就把装了Windows那块盘的ESP分区给删了，打算直接使用装Linux这块盘上的EFI分区来装所有系统的引导文件，遂重建Win引导。</p>
<a id="more"></a>

<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><ul>
<li>装有PE环境的U盘一只</li>
<li>计算机一台</li>
</ul>
<h3 id="启动PE系统"><a href="#启动PE系统" class="headerlink" title="启动PE系统"></a>启动PE系统</h3><p>因为现在已经把原来装有Windows引导的整个分区给删了，但是我另一块硬盘上还有一个EFI分区，所以不涉及到需要新建一个ESP(EFI系统分区)的操作，如果需要可以直接用DG专业工具或傲梅工具来新建ESP</p>
<p>现在我们需要用到的仅仅是PE的CMD来进行下一步的操作，利用Win+R键的组合来快速启动CMD，启动后输入如下命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bcdboot G:\Windows -s C: -f uefi -l zh-cn</span><br></pre></td></tr></table></figure>
<p>解释一下上述bcdboot使用到的各个参数的具体含义</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">G:\<span class="title">Windows</span>      系统安装目录，我的系统是在<span class="title">G</span>盘，打开我的电脑查看你电脑的系统是安装在那个盘，就输入相应的盘符和目录</span></span><br><span class="line"><span class="function">-<span class="title">s</span> <span class="title">C</span>:                   指定<span class="title">EFI</span>分区所在磁盘，我的<span class="title">EFI</span>分区的盘符是<span class="title">C</span></span></span><br><span class="line"><span class="function">-<span class="title">f</span> <span class="title">ntfs</span>         指定启动方式为<span class="title">uefi</span></span></span><br><span class="line"><span class="function">-<span class="title">l</span> <span class="title">zh</span>-<span class="title">cn</span>                指定<span class="title">uefi</span>启动界面的语言为<span class="title">zh</span>-<span class="title">cn</span>（简体中文）</span></span><br></pre></td></tr></table></figure>
<p>执行成功之后会提示你建立引导成功，然后我们再打开C盘查看目录结构，会发现多了如下两个目录，这就代表你成功的重建了Windows的引导</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:/<span class="title">EFI</span>/<span class="title">boot</span>/</span></span><br><span class="line"><span class="function"><span class="title">C</span>:/<span class="title">EFI</span>/<span class="title">microsoft</span>/</span></span><br></pre></td></tr></table></figure>
<h3 id="重启电脑"><a href="#重启电脑" class="headerlink" title="重启电脑"></a>重启电脑</h3><p><img src="https://image.cpolo.cn/%E9%87%8D%E5%BB%BAWindows%E5%BC%95%E5%AF%BC%E7%9A%84%E4%B8%80%E6%AC%A1%E6%93%8D%E4%BD%9C/clover.jpg-cpolo.cn" alt="重建windows引导"><br><b>哈哈，发现熟悉Windows启动项再次回来了</b></p>
]]></content>
      <categories>
        <category>系统</category>
        <category>Windows</category>
        <category>引导</category>
        <category>Clover</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>UEFI</tag>
        <tag>Clover</tag>
        <tag>引导</tag>
      </tags>
  </entry>
  <entry>
    <title>kali linux安装搜狗输入法</title>
    <url>/2019/01/09/kali-linux%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<h4 id="安装fcitx框架"><a href="#安装fcitx框架" class="headerlink" title="安装fcitx框架"></a>安装fcitx框架</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y install fcitx fcitx-libs libfcitx-qt0 libopencc2 libopencc2-data</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="下载搜狗输入法deb包"><a href="#下载搜狗输入法deb包" class="headerlink" title="下载搜狗输入法deb包"></a>下载搜狗输入法deb包</h4><p>搜狗输入法Linux版：<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">https://pinyin.sogou.com/linux/?r=pinyin</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>dpkg安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">dpkg -i 包名  例如：</span></span><br><span class="line">dpkg -i ./sogouinput_linux.deb</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>debian</category>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>linux</tag>
        <tag>输入法</tag>
      </tags>
  </entry>
  <entry>
    <title>kali linux安装NVIDIA显卡驱动</title>
    <url>/2019/01/07/kali-linux%E5%AE%89%E8%A3%85NVIDIA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h4 id="安装GCC-7-3-0"><a href="#安装GCC-7-3-0" class="headerlink" title="安装GCC 7.3.0"></a>安装GCC 7.3.0</h4><h4 id="先把系统里已有的版本卸载"><a href="#先把系统里已有的版本卸载" class="headerlink" title="先把系统里已有的版本卸载"></a>先把系统里已有的版本卸载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get purge -y gcc g++</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="下载GCC-7-3-0源码包"><a href="#下载GCC-7-3-0源码包" class="headerlink" title="下载GCC 7.3.0源码包"></a>下载GCC 7.3.0源码包</h4><p>科大开源镜像站的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.ustc.edu.cn/gnu/gcc/gcc-7.3.0/gcc-7.3.0.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf gcc-7.3.0.tar.gz</span><br><span class="line">cd gcc-7.3.0</span><br></pre></td></tr></table></figure>
<h4 id="运行-contrib-download-prerequisites"><a href="#运行-contrib-download-prerequisites" class="headerlink" title="运行./contrib/download_prerequisites"></a>运行./contrib/download_prerequisites</h4><p>解决依赖关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites</span><br></pre></td></tr></table></figure>
<h4 id="建立一个输出目录"><a href="#建立一个输出目录" class="headerlink" title="建立一个输出目录"></a>建立一个输出目录</h4><p>将中间用到的所有文件都输出到这个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir gcc-build-7.3.0</span><br><span class="line">cd gcc-build-7.3.0</span><br></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br></pre></td></tr></table></figure>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>需要的时间不短，可以先看部电影</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<h1 id="2-安装NVIDIA驱动"><a href="#2-安装NVIDIA驱动" class="headerlink" title="2.安装NVIDIA驱动"></a>2.安装NVIDIA驱动</h1><h4 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h4><p>进入nvidia官网，找到适合自己显卡的驱动，操作系统选择Linux<br>地址：<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">https://www.nvidia.cn/Download/index.aspx?lang=cn</a></p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>赋予其权限并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a+x NVIDIA-Linux-x86_64-410.93.run</span><br><span class="line">./NVIDIA-Linux-x86_64-410.93.run</span><br></pre></td></tr></table></figure>
<p>注意下载的文件名，替换成你自己的<br>所有的选项都选择yes</p>
]]></content>
      <tags>
        <tag>kali</tag>
        <tag>linux</tag>
        <tag>显卡驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali2.0设置默认启动级别</title>
    <url>/2019/01/02/Kali2-0%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Kali2-0设置默认启动级别"><a href="#Kali2-0设置默认启动级别" class="headerlink" title="Kali2.0设置默认启动级别"></a>Kali2.0设置默认启动级别</h1><ul>
<li><p>先删除/etc/systemd/system/default.target</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f /etc/systemd/system/default.target</span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>

<ul>
<li><p>创建链接文件，使用systemctl命令创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>查看当前运行级别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runlevel</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Debian</category>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>2019,又是一年</title>
    <url>/2019/01/01/2019-%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4/</url>
    <content><![CDATA[<h2 id="2019，转眼又是一年！"><a href="#2019，转眼又是一年！" class="headerlink" title="2019，转眼又是一年！"></a>2019，转眼又是一年！</h2><h3 id="新的一年，加油"><a href="#新的一年，加油" class="headerlink" title="新的一年，加油"></a>新的一年，加油</h3>]]></content>
      <categories>
        <category>2019</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
</search>
