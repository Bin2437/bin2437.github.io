<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bin&#39;s Blog</title>
  
  <subtitle>不求俯仰天地，但求无愧于心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cpolo.cn/"/>
  <updated>2020-02-14T10:31:53.628Z</updated>
  <id>https://cpolo.cn/</id>
  
  <author>
    <name>Bin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码审计</title>
    <link href="https://cpolo.cn/2020/02/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>https://cpolo.cn/2020/02/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</id>
    <published>2020-02-08T08:16:30.000Z</published>
    <updated>2020-02-14T10:31:53.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><blockquote><p>顾名思义就是检查<a href="https://baike.baidu.com/item/源代码/3969" target="_blank" rel="noopener">源代码</a>中的安全缺陷，检查程序源代码是否存在安全隐患，或者有编码不规范的地方，通过自动化工具或者人工审查的方式，对程序源代码逐条进行检查和分析，发现这些源代码缺陷引发的安全漏洞，并提供代码修订措施和建议。</p></blockquote><a id="more"></a><h3 id="通用审计思路"><a href="#通用审计思路" class="headerlink" title="通用审计思路"></a>通用审计思路</h3><ul><li><p>根据敏感函数回溯参数传递过程</p><ul><li><p>优点</p><p>只需要搜索相应敏感关键字，即可快速地挖掘想要的漏洞，具有可定向挖掘和高效、高质量的优点</p></li><li><p>缺点</p><p>由于没有通读代码，对程序的整体框架了解不够深入，在挖掘漏洞时定位利用点会话费一点时间，另外对逻辑漏洞会覆盖不到</p></li></ul></li><li><p>查找可控变量，正向追踪变量传递过程</p></li><li><p>寻找敏感功能点，通读功能点代码</p><ul><li>几种经常出现漏洞的功能点<ul><li>文件上传功能</li><li>文件管理功能</li><li>登录认证 功能</li><li>找回密码功能</li></ul></li></ul></li><li><p>直接通读全文代码</p><ul><li>流程<ul><li>查看网站逻辑结构</li><li>审计关键文件代码</li><li>审计配置文件</li><li>审计如index.php入口文件</li><li>审计其它功能入口文件</li></ul></li><li>优点<ul><li>更好的了解程序的架构以及业务逻辑，能够挖掘到更多，更高质量的逻辑漏洞</li></ul></li><li>缺点<ul><li>话费的时间比较多，新手用这种方式比较吃力</li></ul></li></ul></li></ul><h3 id="常见的危险函数和特殊函数"><a href="#常见的危险函数和特殊函数" class="headerlink" title="常见的危险函数和特殊函数"></a>常见的危险函数和特殊函数</h3><ul><li><p>PHP代码执行函数</p><ul><li>eval ( string <code>$code</code> ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><ul><li>把字符串作为PHP代码来执行</li><li>很多常见的webshell都是利用eval()来执行具体操作的</li></ul></li><li>assert()<ul><li>版本<ul><li>PHP 5<ul><li>assert ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$assertion</code> [, string <code>$description</code> ] ) : bool</li></ul></li><li>PHP 7<ul><li>assert ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$assertion</code> [, Throwable <code>$exception</code> ] ) : bool</li></ul></li></ul></li><li>检查指定的 <code>assertion</code> 并在结果为 <strong><code>FALSE</code></strong> 时采取适当的行动。<ul><li>如果 <code>assertion</code> 是字符串，它将会被 <strong>assert()</strong> 当做 PHP 代码来执行。 <code>assertion</code> 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 <code>assertion</code> 表达式。 这意味着如果你传入了 boolean 的条件作为 <code>assertion</code>，这个条件将不会显示为断言函数的参数；在调用你定义的 <a href="https://www.php.net/manual/zh/function.assert-options.php" target="_blank" rel="noopener">assert_options()</a> 处理函数时，条件会转换为字符串，而布尔值 <strong><code>FALSE</code></strong> 会被转换成空字符串。</li></ul></li><li>因为大多数安全软件把eval()列入黑名单了，所以利用assert()代替eval()来执行具体操作</li></ul></li><li>preg_replace ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$pattern</code> , <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$replacement</code> , <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$subject</code> [, int <code>$limit</code> = -1 [, int <code>&amp;$count</code> ]] ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><ul><li>搜索<code>subject</code>中匹配<code>pattern</code>的部分， 以<code>replacement</code>进行替换。</li></ul></li><li>create_function ( string <code>$args</code> , string <code>$code</code> ) : string<ul><li>根据传递的参数来创建一个匿名函数，并返回一个唯一的名称，一般赋给一个变量。</li></ul></li><li>call_user_func ( <a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">callable</a> <code>$callback</code> [, <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$parameter</code> [, <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$...</code> ]] ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><ul><li>第一个参数 <code>callback</code> 是被调用的回调函数，其余参数是回调函数的参数。</li></ul></li><li>call_user_func_array ( <a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">callable</a> <code>$callback</code> , array <code>$param_arr</code> ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><ul><li>把第一个参数作为回调函数（<code>callback</code>）调用，把参数数组作（<code>param_arr</code>）为回调函数的的参数传入。</li></ul></li></ul></li><li><p>文件包含函数</p><pre class="mermaid">  graph LRA[文件包含] --> B("include()")A --> C("require()")A --> D("include_once()")A --> E("require_once()")</pre></li></ul><p>​                   </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;顾名思义就是检查&lt;a href=&quot;https://baike.baidu.com/item/源代码/3969&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源代码&lt;/a&gt;中的安全缺陷，检查程序源代码是否存在安全隐患，或者有编码不规范的地方，通过自动化工具或者人工审查的方式，对程序源代码逐条进行检查和分析，发现这些源代码缺陷引发的安全漏洞，并提供代码修订措施和建议。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="https://cpolo.cn/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
      <category term="代码审计，审计方法" scheme="https://cpolo.cn/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%8C%E5%AE%A1%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="WEB安全" scheme="https://cpolo.cn/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
      <category term="代码审计" scheme="https://cpolo.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>hexo升级</title>
    <link href="https://cpolo.cn/2020/02/08/hexo%E5%8D%87%E7%BA%A7/"/>
    <id>https://cpolo.cn/2020/02/08/hexo%E5%8D%87%E7%BA%A7/</id>
    <published>2020-02-08T05:49:13.000Z</published>
    <updated>2020-02-08T07:39:26.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了-手动狗头"><a href="#Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了-手动狗头" class="headerlink" title="Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了[手动狗头]"></a>Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了[手动狗头]</h3><h4 id="更新还是有必要的"><a href="#更新还是有必要的" class="headerlink" title="更新还是有必要的"></a>更新还是有必要的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br><span class="line">cd hexo</span><br><span class="line"># 到你博客目录下边</span><br><span class="line">ncu</span><br><span class="line"># 检查更新</span><br><span class="line">ncu -u</span><br><span class="line"># 确认升级</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="https://image.cpolo.cn/hexo%E5%8D%87%E7%BA%A7/success.png" alt="Success"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了-手动狗头&quot;&gt;&lt;a href=&quot;#Hexo真是令人省心，搭建好博客以后太久不管再接手时hexo可能已经迭代好几个版本了-手动狗头&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://cpolo.cn/tags/hexo/"/>
    
      <category term="npm" scheme="https://cpolo.cn/tags/npm/"/>
    
      <category term="博客" scheme="https://cpolo.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu搭建VSFTPD</title>
    <link href="https://cpolo.cn/2020/01/27/%E6%90%AD%E5%BB%BAVSFTPD/"/>
    <id>https://cpolo.cn/2020/01/27/%E6%90%AD%E5%BB%BAVSFTPD/</id>
    <published>2020-01-27T10:31:43.000Z</published>
    <updated>2020-01-27T10:35:08.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-安装VSFTPD"><a href="#Ubuntu-安装VSFTPD" class="headerlink" title="Ubuntu 安装VSFTPD"></a>Ubuntu 安装VSFTPD</h1><h5 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y vsftpd</span><br></pre></td></tr></table></figure><h5 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br><span class="line"></span><br><span class="line">listen=YES</span><br><span class="line">listen_ipv6=NO</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line"><span class="meta">#</span><span class="bash">check_shell=NO</span></span><br></pre></td></tr></table></figure><h5 id="新建一个ftp用户"><a href="#新建一个ftp用户" class="headerlink" title="新建一个ftp用户"></a>新建一个ftp用户</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -g ftp -M -d /var/www/html/ -s /usr/bin/nologin username</span><br><span class="line">passwd username</span><br></pre></td></tr></table></figure><h5 id="取消vsftpd对shell的检测"><a href="#取消vsftpd对shell的检测" class="headerlink" title="取消vsftpd对shell的检测"></a>取消vsftpd对shell的检测</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shells</span><br><span class="line"><span class="meta">#</span><span class="bash">把 /sbin/nologin /usr/bin/nologin 或者是 /bin/<span class="literal">false</span> 加到 /etc/shells 中去！</span></span><br></pre></td></tr></table></figure><p>其实vsftpd对本地用户鉴权的过程中是可以检查用户shell的合法性的，而且默认就启用了。虽然你可以在配置文件中通过添加 check_shell=NO来取消vsftpd对shell的检测，但是这个配置项要生效却有个前提：编译的时候不能包含PAM特性（一种*nix系统中的插件式身份鉴别模块），而ubuntu等发行版的二进制包并不能满足这点，所以除非你是自己编译的vsftpd，这个配置项是没有多少用的。</p><p>要解决这个问题，还得继续问：vsftpd是怎么检查一个shell是否合法呢？其实这个答案很简单，vsftpd读取 /etc/shells 这个文件，如果用户的shell在这个文件里存在，就认为合法，否则即使你输入了正确的密码，仍然会给你一个530，哈哈。<br>    所以，解决办法就是：把 /sbin/nologin /usr/bin/nologin 或者是 /bin/false 加到 /etc/shells 中去！</p><h5 id="配置ftp用户家目录权限"><a href="#配置ftp用户家目录权限" class="headerlink" title="配置ftp用户家目录权限"></a>配置ftp用户家目录权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 555 /var/www/html/</span><br></pre></td></tr></table></figure><p>从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报该错误。</p><p> 要修复这个错误，可以用命令chmod a-w /home/user去除用户主目录的写权限，注意把目录替换成你自己的。或者你可以在vsftpd的配置文件中增加下列两项中的一项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd.conf</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu-安装VSFTPD&quot;&gt;&lt;a href=&quot;#Ubuntu-安装VSFTPD&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 安装VSFTPD&quot;&gt;&lt;/a&gt;Ubuntu 安装VSFTPD&lt;/h1&gt;&lt;h5 id=&quot;安装vsftpd&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://cpolo.cn/categories/Linux/"/>
    
      <category term="Ubuntu" scheme="https://cpolo.cn/categories/Ubuntu/"/>
    
      <category term="FTP" scheme="https://cpolo.cn/categories/Ubuntu/FTP/"/>
    
    
      <category term="Linux" scheme="https://cpolo.cn/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://cpolo.cn/tags/Ubuntu/"/>
    
      <category term="FTP" scheme="https://cpolo.cn/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>Mac开启原生NTFS读写功能</title>
    <link href="https://cpolo.cn/2019/05/23/Mac%E5%BC%80%E5%90%AF%E5%8E%9F%E7%94%9FNTFS%E8%AF%BB%E5%86%99%E5%8A%9F%E8%83%BD/"/>
    <id>https://cpolo.cn/2019/05/23/Mac%E5%BC%80%E5%90%AF%E5%8E%9F%E7%94%9FNTFS%E8%AF%BB%E5%86%99%E5%8A%9F%E8%83%BD/</id>
    <published>2019-05-23T00:32:55.000Z</published>
    <updated>2020-01-27T07:54:42.160Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mac早在10-5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal-app来开启这个功能！"><a href="#Mac早在10-5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal-app来开启这个功能！" class="headerlink" title="Mac早在10.5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal.app来开启这个功能！"></a>Mac早在10.5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal.app来开启这个功能！</h4><p>打开Terminal终端工具，这是Mac自带的终端工具，非常方便好使。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br><span class="line">//查看你电脑所有磁盘</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diskutil info /Volumes/磁盘名 | grep UUID</span><br><span class="line">//因为UUID是磁盘真正的且是唯一的标识符，而我们的磁盘名并非总是不变的，所以使用UUID来开启NTFS读写是更佳的！</span><br></pre></td></tr></table></figure><p>Return (Enter) 后会出现“Volume UUID”和“Disk / Partition UUID”两行内容。<br>我们只需要使用Volume UUID即可</p><p>接下来复制这组UUID，再使用VIM将UUID写入/etc/fstab中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br><span class="line">//进入VIM后按i键进入编辑模式</span><br><span class="line">//将之前复制的UUID按照这个格式填入</span><br><span class="line">UUID=磁盘标识符 none ntfs rw,auto,nobrowse</span><br><span class="line">//填入完后按ESC键退出编辑模式，切换到英文半角状态":wq"，输入一个冒号wq后退出</span><br></pre></td></tr></table></figure><p>在磁盘工具中重新装载该磁盘后就可以对该磁盘进行写入操作了</p><h5 id="将存储器显示在Finder的方法其实也非常简单"><a href="#将存储器显示在Finder的方法其实也非常简单" class="headerlink" title="将存储器显示在Finder的方法其实也非常简单"></a>将存储器显示在Finder的方法其实也非常简单</h5><p>只需要将”磁盘工具”-&gt;”显示简介”-&gt;存储器Finder标题栏的图标长按并拖入Finder的个人收藏栏中就ok了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Mac早在10-5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这个功能！但是我们可以通过Terminal-app来开启这个功能！&quot;&gt;&lt;a href=&quot;#Mac早在10-5的时候其实原生就支持NTFS读写的，只不过后来由于微软的限制就关闭了这
      
    
    </summary>
    
    
    
      <category term="MacOS" scheme="https://cpolo.cn/tags/MacOS/"/>
    
      <category term="NTFS" scheme="https://cpolo.cn/tags/NTFS/"/>
    
  </entry>
  
  <entry>
    <title>Debian Linux 修改时区</title>
    <link href="https://cpolo.cn/2019/04/23/Ubuntu%20%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/"/>
    <id>https://cpolo.cn/2019/04/23/Ubuntu%20%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/</id>
    <published>2019-04-23T02:16:33.000Z</published>
    <updated>2020-01-27T10:37:45.973Z</updated>
    
    <content type="html"><![CDATA[<h4 id="UTC时区切换到CST时区"><a href="#UTC时区切换到CST时区" class="headerlink" title="UTC时区切换到CST时区"></a>UTC时区切换到CST时区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo "export TZ='Asia/Shanghai'" &gt;&gt; /etc/profile</span><br><span class="line"></span><br><span class="line">cat /etc/profile | grep TZ</span><br></pre></td></tr></table></figure><p>//查看是否写入成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/profile | grep TZ</span><br></pre></td></tr></table></figure><p>//编译使其生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>//查看当前时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;UTC时区切换到CST时区&quot;&gt;&lt;a href=&quot;#UTC时区切换到CST时区&quot; class=&quot;headerlink&quot; title=&quot;UTC时区切换到CST时区&quot;&gt;&lt;/a&gt;UTC时区切换到CST时区&lt;/h4&gt;&lt;figure class=&quot;highlight shel
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://cpolo.cn/categories/Linux/"/>
    
      <category term="Debian" scheme="https://cpolo.cn/categories/Debian/"/>
    
    
      <category term="Linux" scheme="https://cpolo.cn/tags/Linux/"/>
    
      <category term="Debian" scheme="https://cpolo.cn/tags/Debian/"/>
    
      <category term="时区" scheme="https://cpolo.cn/tags/%E6%97%B6%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Nginx+Ngrok共用80端口</title>
    <link href="https://cpolo.cn/2019/04/21/Nginx-Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/"/>
    <id>https://cpolo.cn/2019/04/21/Nginx-Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/</id>
    <published>2019-04-21T14:28:49.000Z</published>
    <updated>2020-01-27T14:03:17.208Z</updated>
    
    <content type="html"><![CDATA[<p>大多数情况下，我们的服务器不会只有一个ngrok服务，并且80端口通常都是给Nginx等服务准备的！在一系列的需求下，Ngrok和Nginx就有共用80端口的必要</p><h3 id="解决姿势"><a href="#解决姿势" class="headerlink" title="解决姿势"></a>解决姿势</h3><p>我们的服务器一般都有着公网和内网之分，所以网卡也有两个，所以我们让Nginx监听公网80端口，Ngrok监听内网80端口就完美的解决了这个问题</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>带有公网ip的服务器一台</li><li>Nginx服务</li><li>Ngork服务</li></ul><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li>查看自己服务器网卡数量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><p><img src="https://image.cpolo.cn/Nginx+Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/ifconfig%20-a.png" alt="ifconfig -a"></p><p>如上图所示，我有一个内网网卡，ip是172.16.0.14，虽然我只有一个内网网卡也是可以实现的</p><ul><li>配置一个新的网卡：192.168.24.37（如果你有两块网卡请忽略这一步）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.24.37/24 up</span><br></pre></td></tr></table></figure><ul><li>再通过ifconfig -a 命令查看网卡</li></ul><p><img src="https://image.cpolo.cn/Nginx+Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/new%20eth0-0.png" alt="ifconfig -a"></p><p>如图，我现在有了172.16.0.14（内网网卡，但实际上我的公网ip是别的服务器转发给我这个ip的，所以这个ip对我的服务器来说，我所有的外网请求都来自这个ip）和192.168.24.37（自己添加的）</p><ul><li>修改Nginx配置文件</li></ul><p>因为我的nginx主配置文件里配置了自动加载配置文件目录下vhost子目录的所有单独的虚拟主机配置文件，所以我只需要在vhost目录下新建一个ngrok.conf文件就好了</p><p>配置如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream ngrok &#123;</span><br><span class="line">        server 192.168.24.37:80;</span><br><span class="line">        server 192.168.24.37:443;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 172.16.0.14:80;</span><br><span class="line">        server_name example.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_set_header Host $http_host;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                proxy_set_header X-Scheme $scheme;</span><br><span class="line">                proxy_pass_header Server;</span><br><span class="line">                proxy_pass http://ngrok;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用nginx来反代，不会的照着配置文件改改就好</p><ul><li>启动Ngrok监听内网(192.168.24.37)的80端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok -domain='example.com' -httpAddr='192.168.24.37:80' -httpsAddr='192.168.24.37:443'</span><br></pre></td></tr></table></figure><ul><li>重载Nginx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><ul><li>启动ngrok客户端试试</li></ul><p><img src="https://image.cpolo.cn/Nginx+Ngrok%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3/startngrok.png" alt="start ngrok"></p><p>Beautiful</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大多数情况下，我们的服务器不会只有一个ngrok服务，并且80端口通常都是给Nginx等服务准备的！在一系列的需求下，Ngrok和Nginx就有共用80端口的必要&lt;/p&gt;
&lt;h3 id=&quot;解决姿势&quot;&gt;&lt;a href=&quot;#解决姿势&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://cpolo.cn/categories/Linux/"/>
    
      <category term="Nginx" scheme="https://cpolo.cn/categories/Nginx/"/>
    
      <category term="反向代理" scheme="https://cpolo.cn/categories/Nginx/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="Nginx" scheme="https://cpolo.cn/tags/Nginx/"/>
    
      <category term="Ngrok" scheme="https://cpolo.cn/tags/Ngrok/"/>
    
      <category term="内网穿透" scheme="https://cpolo.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="反向代理" scheme="https://cpolo.cn/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>重建Windows引导的一次操作</title>
    <link href="https://cpolo.cn/2019/04/04/%E9%87%8D%E5%BB%BAWindows%E5%BC%95%E5%AF%BC%E7%9A%84%E4%B8%80%E6%AC%A1%E6%93%8D%E4%BD%9C/"/>
    <id>https://cpolo.cn/2019/04/04/%E9%87%8D%E5%BB%BAWindows%E5%BC%95%E5%AF%BC%E7%9A%84%E4%B8%80%E6%AC%A1%E6%93%8D%E4%BD%9C/</id>
    <published>2019-04-04T09:24:35.000Z</published>
    <updated>2020-01-27T13:41:09.505Z</updated>
    
    <content type="html"><![CDATA[<p>由于电脑Windows和Linux系统都不在一个硬盘上，所以每个硬盘都有一个EFI分区。本着有一个引导分区就够了的原则就把装了Windows那块盘的ESP分区给删了，打算直接使用装Linux这块盘上的EFI分区来装所有系统的引导文件，遂重建Win引导。</p><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><ul><li>装有PE环境的U盘一只</li><li>计算机一台</li></ul><h3 id="启动PE系统"><a href="#启动PE系统" class="headerlink" title="启动PE系统"></a>启动PE系统</h3><p>因为现在已经把原来装有Windows引导的整个分区给删了，但是我另一块硬盘上还有一个EFI分区，所以不涉及到需要新建一个ESP(EFI系统分区)的操作，如果需要可以直接用DG专业工具或傲梅工具来新建ESP</p><p>现在我们需要用到的仅仅是PE的CMD来进行下一步的操作，利用Win+R键的组合来快速启动CMD，启动后输入如下命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdboot G:\Windows -s C: -f uefi -l zh-cn</span><br></pre></td></tr></table></figure><p>解释一下上述bcdboot使用到的各个参数的具体含义</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">G:\<span class="title">Windows</span>      系统安装目录，我的系统是在<span class="title">G</span>盘，打开我的电脑查看你电脑的系统是安装在那个盘，就输入相应的盘符和目录</span></span><br><span class="line"><span class="function">-<span class="title">s</span> <span class="title">C</span>:                   指定<span class="title">EFI</span>分区所在磁盘，我的<span class="title">EFI</span>分区的盘符是<span class="title">C</span></span></span><br><span class="line"><span class="function">-<span class="title">f</span> <span class="title">ntfs</span>         指定启动方式为<span class="title">uefi</span></span></span><br><span class="line"><span class="function">-<span class="title">l</span> <span class="title">zh</span>-<span class="title">cn</span>                指定<span class="title">uefi</span>启动界面的语言为<span class="title">zh</span>-<span class="title">cn</span>（简体中文）</span></span><br></pre></td></tr></table></figure><p>执行成功之后会提示你建立引导成功，然后我们再打开C盘查看目录结构，会发现多了如下两个目录，这就代表你成功的重建了Windows的引导</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:/<span class="title">EFI</span>/<span class="title">boot</span>/</span></span><br><span class="line"><span class="function"><span class="title">C</span>:/<span class="title">EFI</span>/<span class="title">microsoft</span>/</span></span><br></pre></td></tr></table></figure><h3 id="重启电脑"><a href="#重启电脑" class="headerlink" title="重启电脑"></a>重启电脑</h3><p><img title='Clover' src='https://image.cpolo.cn/重建Windows引导的一次操作/clover.jpg' width='500px' /><br /><br><b>哈哈，发现熟悉Windows启动项再次回来了</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于电脑Windows和Linux系统都不在一个硬盘上，所以每个硬盘都有一个EFI分区。本着有一个引导分区就够了的原则就把装了Windows那块盘的ESP分区给删了，打算直接使用装Linux这块盘上的EFI分区来装所有系统的引导文件，遂重建Win引导。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
    
      <category term="Windows" scheme="https://cpolo.cn/tags/Windows/"/>
    
      <category term="UEFI" scheme="https://cpolo.cn/tags/UEFI/"/>
    
      <category term="Clover" scheme="https://cpolo.cn/tags/Clover/"/>
    
      <category term="引导" scheme="https://cpolo.cn/tags/%E5%BC%95%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>kali linux安装搜狗输入法</title>
    <link href="https://cpolo.cn/2019/01/09/kali-linux%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    <id>https://cpolo.cn/2019/01/09/kali-linux%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/</id>
    <published>2019-01-09T07:17:12.000Z</published>
    <updated>2019-04-22T01:05:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装fcitx框架"><a href="#安装fcitx框架" class="headerlink" title="安装fcitx框架"></a>安装fcitx框架</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y install fcitx fcitx-libs libfcitx-qt0 libopencc2 libopencc2-data</span><br></pre></td></tr></table></figure><h4 id="下载搜狗输入法deb包"><a href="#下载搜狗输入法deb包" class="headerlink" title="下载搜狗输入法deb包"></a>下载搜狗输入法deb包</h4><p>搜狗输入法Linux版：<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">https://pinyin.sogou.com/linux/?r=pinyin</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>dpkg安装</p><pre><code class="shell"><span class="meta">#</span><span class="bash">dpkg -i 包名  例如：</span>dpkg -i ./sogouinput_linux.deb</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;安装fcitx框架&quot;&gt;&lt;a href=&quot;#安装fcitx框架&quot; class=&quot;headerlink&quot; title=&quot;安装fcitx框架&quot;&gt;&lt;/a&gt;安装fcitx框架&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
    
      <category term="kali" scheme="https://cpolo.cn/tags/kali/"/>
    
      <category term="linux" scheme="https://cpolo.cn/tags/linux/"/>
    
      <category term="输入法" scheme="https://cpolo.cn/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>kali linux安装NVIDIA显卡驱动</title>
    <link href="https://cpolo.cn/2019/01/07/kali-linux%E5%AE%89%E8%A3%85NVIDIA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
    <id>https://cpolo.cn/2019/01/07/kali-linux%E5%AE%89%E8%A3%85NVIDIA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</id>
    <published>2019-01-07T06:08:17.000Z</published>
    <updated>2019-04-22T01:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装GCC-7-3-0"><a href="#1-安装GCC-7-3-0" class="headerlink" title="1.安装GCC 7.3.0"></a>1.安装GCC 7.3.0</h1><h4 id="先把系统里已有的版本卸载"><a href="#先把系统里已有的版本卸载" class="headerlink" title="先把系统里已有的版本卸载"></a>先把系统里已有的版本卸载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get purge -y gcc g++</span><br></pre></td></tr></table></figure><h4 id="下载GCC-7-3-0源码包"><a href="#下载GCC-7-3-0源码包" class="headerlink" title="下载GCC 7.3.0源码包"></a>下载GCC 7.3.0源码包</h4><p>科大开源镜像站的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.ustc.edu.cn/gnu/gcc/gcc-7.3.0/gcc-7.3.0.tar.gz</span><br></pre></td></tr></table></figure><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf gcc-7.3.0.tar.gz</span><br><span class="line">cd gcc-7.3.0</span><br></pre></td></tr></table></figure><h4 id="运行-contrib-download-prerequisites"><a href="#运行-contrib-download-prerequisites" class="headerlink" title="运行./contrib/download_prerequisites"></a>运行./contrib/download_prerequisites</h4><p>解决依赖关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./contrib/download_prerequisites</span><br></pre></td></tr></table></figure><h4 id="建立一个输出目录"><a href="#建立一个输出目录" class="headerlink" title="建立一个输出目录"></a>建立一个输出目录</h4><p>将中间用到的所有文件都输出到这个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir gcc-build-7.3.0</span><br><span class="line">cd gcc-build-7.3.0</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br></pre></td></tr></table></figure><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>需要的时间不短，可以先看部电影</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h1 id="2-安装NVIDIA驱动"><a href="#2-安装NVIDIA驱动" class="headerlink" title="2.安装NVIDIA驱动"></a>2.安装NVIDIA驱动</h1><h4 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h4><p>进入nvidia官网，找到适合自己显卡的驱动，操作系统选择Linux<br>地址：<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">https://www.nvidia.cn/Download/index.aspx?lang=cn</a></p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>赋予其权限并执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x NVIDIA-Linux-x86_64-410.93.run</span><br><span class="line">./NVIDIA-Linux-x86_64-410.93.run</span><br></pre></td></tr></table></figure><p>注意下载的文件名，替换成你自己的<br>所有的选项都选择yes</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-安装GCC-7-3-0&quot;&gt;&lt;a href=&quot;#1-安装GCC-7-3-0&quot; class=&quot;headerlink&quot; title=&quot;1.安装GCC 7.3.0&quot;&gt;&lt;/a&gt;1.安装GCC 7.3.0&lt;/h1&gt;&lt;h4 id=&quot;先把系统里已有的版本卸载&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="kali" scheme="https://cpolo.cn/tags/kali/"/>
    
      <category term="linux" scheme="https://cpolo.cn/tags/linux/"/>
    
      <category term="显卡驱动" scheme="https://cpolo.cn/tags/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kali2.0设置默认启动级别</title>
    <link href="https://cpolo.cn/2019/01/02/Kali2-0%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E7%BA%A7%E5%88%AB/"/>
    <id>https://cpolo.cn/2019/01/02/Kali2-0%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E7%BA%A7%E5%88%AB/</id>
    <published>2019-01-02T10:29:23.000Z</published>
    <updated>2020-01-27T10:31:00.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kali2-0设置默认启动级别"><a href="#Kali2-0设置默认启动级别" class="headerlink" title="Kali2.0设置默认启动级别"></a>Kali2.0设置默认启动级别</h1><ul><li><p>先删除/etc/systemd/system/default.target</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /etc/systemd/system/default.target</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建链接文件，使用systemctl命令创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看当前运行级别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runlevel</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kali2-0设置默认启动级别&quot;&gt;&lt;a href=&quot;#Kali2-0设置默认启动级别&quot; class=&quot;headerlink&quot; title=&quot;Kali2.0设置默认启动级别&quot;&gt;&lt;/a&gt;Kali2.0设置默认启动级别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先删除/etc/s
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://cpolo.cn/categories/Linux/"/>
    
      <category term="Debian" scheme="https://cpolo.cn/categories/Debian/"/>
    
      <category term="Kali" scheme="https://cpolo.cn/categories/Debian/Kali/"/>
    
    
      <category term="Linux" scheme="https://cpolo.cn/tags/Linux/"/>
    
      <category term="Kali" scheme="https://cpolo.cn/tags/Kali/"/>
    
  </entry>
  
  <entry>
    <title>2019,又是一年</title>
    <link href="https://cpolo.cn/2019/01/01/2019-%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4/"/>
    <id>https://cpolo.cn/2019/01/01/2019-%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4/</id>
    <published>2019-01-01T11:06:25.000Z</published>
    <updated>2020-01-27T09:55:08.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019，转眼又是一年！"><a href="#2019，转眼又是一年！" class="headerlink" title="2019，转眼又是一年！"></a>2019，转眼又是一年！</h2><h3 id="新的一年，加油"><a href="#新的一年，加油" class="headerlink" title="新的一年，加油"></a>新的一年，加油</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2019，转眼又是一年！&quot;&gt;&lt;a href=&quot;#2019，转眼又是一年！&quot; class=&quot;headerlink&quot; title=&quot;2019，转眼又是一年！&quot;&gt;&lt;/a&gt;2019，转眼又是一年！&lt;/h2&gt;&lt;h3 id=&quot;新的一年，加油&quot;&gt;&lt;a href=&quot;#新的一年，加
      
    
    </summary>
    
    
      <category term="2019" scheme="https://cpolo.cn/categories/2019/"/>
    
    
      <category term="2019" scheme="https://cpolo.cn/tags/2019/"/>
    
  </entry>
  
</feed>
